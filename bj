#!/bin/bash
#
# bj - Minimal Bullet Journal
# Version: 1.0.0

set -euo pipefail

# Constants
readonly VERSION="1.0.0"
readonly BJ_ROOT="${BJ_HOME:-$HOME/bj}"
readonly CACHE_WORKSPACE="$BJ_ROOT/.current_workspace"
readonly CACHE_FILE="$BJ_ROOT/.current_date"
readonly CACHE_MODE="$BJ_ROOT/.current_mode"
readonly CACHE_MONTH="$BJ_ROOT/.current_month"
readonly CACHE_YEAR="$BJ_ROOT/.current_year"
readonly HOLIDAYS_FILE="$BJ_ROOT/.holidays"

# Bullet type constants
readonly BULLET_TASK="."
readonly BULLET_PRIORITY="!"
readonly BULLET_DONE="x"
readonly BULLET_EVENT="o"
readonly BULLET_ABANDONED="a"
readonly BULLET_WAITING="w"
readonly BULLET_MIGRATED=">"
readonly BULLET_SCHEDULED="<"
readonly BULLET_NOTE="-"

# Regex patterns
readonly BULLET_PATTERN='[.!xoaw><-]'
readonly INCOMPLETE_PATTERN='[.!w]'
readonly ADD_BULLET_PATTERN='[.!o-]'
readonly CHANGE_BULLET_PATTERN='[!xoaw-]'

# Initialize BJ_ROOT directory
mkdir -p "$BJ_ROOT"

# Get current workspace
get_current_workspace() {
    if [[ -f "$CACHE_WORKSPACE" ]]; then
        cat "$CACHE_WORKSPACE"
    else
        echo "default"
    fi
}

# Set current workspace
set_current_workspace() {
    echo "$1" > "$CACHE_WORKSPACE"
}

# Get workspace directory
get_workspace_dir() {
    local workspace="${1:-$(get_current_workspace)}"
    echo "$BJ_ROOT/$workspace"
}

# Migrate existing files to default workspace (one-time migration)
migrate_to_workspaces() {
    # Check if migration is needed (md files in root, no default/ directory)
    local md_files
    md_files=$(ls "$BJ_ROOT"/*.md 2>/dev/null || true)

    if [[ -n "$md_files" ]] && [[ ! -d "$BJ_ROOT/default" ]]; then
        echo "Migrating existing files to 'default' workspace..."
        mkdir -p "$BJ_ROOT/default"

        # Move all .md files to default workspace
        for file in "$BJ_ROOT"/*.md; do
            if [[ -f "$file" ]]; then
                mv "$file" "$BJ_ROOT/default/"
            fi
        done

        echo "Migration complete! All existing files are now in the 'default' workspace."
    fi
}

# Run migration check
migrate_to_workspaces

# Set BJ_DIR to current workspace directory
readonly BJ_DIR="$(get_workspace_dir)"
mkdir -p "$BJ_DIR"

# Get current working date
get_current_date() {
    if [[ -f "$CACHE_FILE" ]]; then
        cat "$CACHE_FILE"
    else
        date +%Y-%m-%d
    fi
}

# Set current working date
set_current_date() {
    echo "$1" > "$CACHE_FILE"
}

# Get current mode (daily/monthly)
get_current_mode() {
    if [[ -f "$CACHE_MODE" ]]; then
        cat "$CACHE_MODE"
    else
        echo "daily"
    fi
}

# Set current mode
set_current_mode() {
    echo "$1" > "$CACHE_MODE"
}

# Get current working month
get_current_month() {
    if [[ -f "$CACHE_MONTH" ]]; then
        cat "$CACHE_MONTH"
    else
        date +%Y-%m
    fi
}

# Set current working month
set_current_month() {
    echo "$1" > "$CACHE_MONTH"
}

# Get current working year
get_current_year() {
    if [[ -f "$CACHE_YEAR" ]]; then
        cat "$CACHE_YEAR"
    else
        date +%Y
    fi
}

# Set current working year
set_current_year() {
    echo "$1" > "$CACHE_YEAR"
}

CURRENT_DATE=$(get_current_date)
CURRENT_MODE=$(get_current_mode)
CURRENT_MONTH=$(get_current_month)
CURRENT_YEAR=$(get_current_year)

# Set FILE based on mode
if [[ "$CURRENT_MODE" == "monthly" ]]; then
    FILE="$BJ_DIR/$CURRENT_MONTH.md"
elif [[ "$CURRENT_MODE" == "future" ]]; then
    FILE="$BJ_DIR/$CURRENT_YEAR.md"
else
    FILE="$BJ_DIR/$CURRENT_DATE.md"
fi

# Create file if needed
if [[ ! -f "$FILE" ]]; then
    if [[ "$CURRENT_MODE" == "monthly" ]]; then
        echo "# $CURRENT_MONTH" > "$FILE"
    elif [[ "$CURRENT_MODE" == "future" ]]; then
        echo "# $CURRENT_YEAR" > "$FILE"
    else
        echo "# $CURRENT_DATE" > "$FILE"
    fi
    echo "" >> "$FILE"
fi

# Portable sed in-place
sed_inplace() {
    if [[ "$OSTYPE" == "darwin"* ]]; then
        sed -i '' "$@"
    else
        sed -i "$@"
    fi
}

# Helper: Show formatted date header
show_date_header() {
    local date_to_show="$1"
    local date_header
    if [[ "$OSTYPE" == "darwin"* ]]; then
        date_header=$(date -j -f "%Y-%m-%d" "$date_to_show" "+%m%d %a" | tr '[:lower:]' '[:upper:]')
    else
        date_header=$(date -d "$date_to_show" "+%m%d %a" | tr '[:lower:]' '[:upper:]')
    fi
    echo "$date_header"
}

# Helper: Show formatted month header
show_month_header() {
    local month_to_show="$1"
    local month_header
    if [[ "$OSTYPE" == "darwin"* ]]; then
        month_header=$(date -j -f "%Y-%m" "$month_to_show" "+%Y %b" | tr '[:lower:]' '[:upper:]')
    else
        month_header=$(date -d "$month_to_show-01" "+%Y %b" | tr '[:lower:]' '[:upper:]')
    fi
    echo "$month_header"
}

# Helper: Check if date is a holiday
is_holiday() {
    local check_date="$1"

    if [[ ! -f "$HOLIDAYS_FILE" ]]; then
        return 1  # No holidays file, so not a holiday
    fi

    # Check if date exists in holidays file
    if grep -q "^${check_date}$" "$HOLIDAYS_FILE"; then
        return 0  # Is a holiday
    else
        return 1  # Not a holiday
    fi
}

# Helper: Check if date is a working day (Mon-Fri, not holiday)
is_working_day() {
    local check_date="$1"

    # Get day of week (1=Mon, 7=Sun)
    local day_of_week
    if [[ "$OSTYPE" == "darwin"* ]]; then
        day_of_week=$(date -j -f "%Y-%m-%d" "$check_date" "+%u")
    else
        day_of_week=$(date -d "$check_date" "+%u")
    fi

    # Check if weekend (6=Sat, 7=Sun)
    if [[ "$day_of_week" -eq 6 ]] || [[ "$day_of_week" -eq 7 ]]; then
        return 1  # Weekend
    fi

    # Check if holiday
    if is_holiday "$check_date"; then
        return 1  # Holiday
    fi

    return 0  # Is a working day
}

# Helper: Get next working day from given date
get_next_working_day() {
    local from_date="$1"
    local next_date="$from_date"

    # Keep adding days until we find a working day
    while true; do
        # Add one day
        if [[ "$OSTYPE" == "darwin"* ]]; then
            next_date=$(date -j -v+1d -f "%Y-%m-%d" "$next_date" "+%Y-%m-%d")
        else
            next_date=$(date -d "$next_date + 1 day" "+%Y-%m-%d")
        fi

        # Check if it's a working day
        if is_working_day "$next_date"; then
            echo "$next_date"
            return 0
        fi
    done
}

# Helper: Get task line number in file
get_task_line() {
    local num="$1"
    local file="${2:-$FILE}"

    local lines
    lines=$(grep -v "^#" "$file" | grep -v "^$" || true)

    local total
    total=$(echo "$lines" | wc -l | tr -d ' ')

    if [[ $num -lt 1 ]] || [[ $num -gt $total ]]; then
        echo "Error: Task $num not found (1-$total)" >&2
        return 1
    fi

    local line_nums
    line_nums=$(grep -n -v "^#" "$file" | grep -v ":$" | cut -d: -f1)
    echo "$line_nums" | sed -n "${num}p"
}

# Helper: Parse date argument to YYYY-MM-DD format
parse_date() {
    local date_arg="$1"

    if [[ "$date_arg" == "today" ]]; then
        date +%Y-%m-%d
    elif [[ "$date_arg" =~ ^[0-9]{8}$ ]]; then
        # YYYYMMDD
        echo "${date_arg:0:4}-${date_arg:4:2}-${date_arg:6:2}"
    elif [[ "$date_arg" =~ ^[0-9]{4}$ ]]; then
        # MMDD
        echo "$(date +%Y)-${date_arg:0:2}-${date_arg:2:2}"
    else
        echo "Error: Invalid date format" >&2
        echo "Date must be in format MMDD or YYYYMMDD" >&2
        echo "Example: 1225 (Dec 25) or 20251225 (Dec 25, 2025)" >&2
        return 1
    fi
}

# Helper: Validate date format
validate_date() {
    local date_str="$1"
    if ! date -j -f "%Y-%m-%d" "$date_str" &>/dev/null && ! date -d "$date_str" &>/dev/null; then
        echo "Error: Invalid date '$date_str'" >&2
        return 1
    fi
    return 0
}

# Helper: Create or ensure file exists
ensure_file() {
    local file_path="$1"
    local file_date="$2"

    if [[ ! -f "$file_path" ]]; then
        echo "# $file_date" > "$file_path"
        echo "" >> "$file_path"
    fi
}

# Helper: Get month name from number (01-12)
get_month_name() {
    local month_num="$1"
    case "$month_num" in
        01) echo "JANUARY" ;;
        02) echo "FEBRUARY" ;;
        03) echo "MARCH" ;;
        04) echo "APRIL" ;;
        05) echo "MAY" ;;
        06) echo "JUNE" ;;
        07) echo "JULY" ;;
        08) echo "AUGUST" ;;
        09) echo "SEPTEMBER" ;;
        10) echo "OCTOBER" ;;
        11) echo "NOVEMBER" ;;
        12) echo "DECEMBER" ;;
        *) echo "UNKNOWN" ;;
    esac
}

# Helper: Get month number from month name (case-insensitive)
get_month_number() {
    local month_name="$1"
    local month_lower=$(echo "$month_name" | tr '[:upper:]' '[:lower:]')

    case "$month_lower" in
        jan|january) echo "01" ;;
        feb|february) echo "02" ;;
        mar|march) echo "03" ;;
        apr|april) echo "04" ;;
        may) echo "05" ;;
        jun|june) echo "06" ;;
        jul|july) echo "07" ;;
        aug|august) echo "08" ;;
        sep|september) echo "09" ;;
        oct|october) echo "10" ;;
        nov|november) echo "11" ;;
        dec|december) echo "12" ;;
        *) echo "" ;;
    esac
}

# Helper: Ensure month section exists in future log
ensure_month_section() {
    local file_path="$1"
    local month_name="$2"

    # Check if month header exists
    if ! grep -q "^\[${month_name}\]$" "$file_path" 2>/dev/null; then
        # Add month header at the end
        echo "" >> "$file_path"
        echo "[${month_name}]" >> "$file_path"
    fi
}

# Helper: Add task to month section in future log
add_to_month_section() {
    local file_path="$1"
    local month_name="$2"
    local task_text="$3"

    # Ensure month section exists
    ensure_month_section "$file_path" "$month_name"

    # Read the entire file into an array
    local lines=()
    local in_target_section=false
    local inserted=false

    while IFS= read -r line || [[ -n "$line" ]]; do
        # Check if we're at the target month header
        if [[ "$line" == "[${month_name}]" ]]; then
            lines+=("$line")
            in_target_section=true
            continue
        fi

        # Check if we hit another month header while in target section
        if [[ "$in_target_section" == "true" ]] && [[ "$line" =~ ^\[.*\]$ ]]; then
            # Insert before this next header
            lines+=("$task_text")
            lines+=("$line")
            inserted=true
            in_target_section=false
            continue
        fi

        lines+=("$line")
    done < "$file_path"

    # If we didn't insert yet (no next header found), add at end
    if [[ "$inserted" == "false" ]] && [[ "$in_target_section" == "true" ]]; then
        lines+=("$task_text")
    fi

    # Write back to file
    printf "%s\n" "${lines[@]}" > "$file_path"
}

# List tasks (without line numbers)
list() {
    # Show header based on mode
    if [[ "$CURRENT_MODE" == "monthly" ]]; then
        echo "[Monthly] $(show_month_header "$CURRENT_MONTH")"
    elif [[ "$CURRENT_MODE" == "future" ]]; then
        echo "[Future Log] $CURRENT_YEAR"
    else
        echo "[Daily] $(show_date_header "$CURRENT_DATE")"
    fi

    local entries
    entries=$(grep -v "^#" "$FILE" | grep -v "^$" || true)

    if [[ -z "$entries" ]]; then
        if [[ "$CURRENT_MODE" == "monthly" ]]; then
            echo "No monthly logs."
        elif [[ "$CURRENT_MODE" == "future" ]]; then
            echo "No future log entries."
        else
            echo "No tasks."
        fi
    else
        # Strip leading spaces for consistent alignment
        echo "$entries" | sed 's/^[[:space:]]*//'
    fi
}

# List logs from specific date/month/year
list_logs() {
    local arg1="$1"
    local arg2="${2:-}"

    # Check if arg1 is "future"
    if [[ "$arg1" == "future" ]]; then
        local year="${arg2:-$(date +%Y)}"
        local future_file="$BJ_DIR/${year}.md"

        if [[ ! -f "$future_file" ]]; then
            echo "[Future Log] $year"
            echo "No future log for $year."
            return 0
        fi

        echo "[Future Log] $year"
        local entries
        entries=$(grep -v "^#" "$future_file" | grep -v "^$" || true)

        if [[ -z "$entries" ]]; then
            echo "No future log entries."
        else
            echo "$entries" | sed 's/^[[:space:]]*//'
        fi
        return 0
    fi

    # Check if arg1 is a day number (01-31)
    if [[ "$arg1" =~ ^[0-9]{1,2}$ ]]; then
        # Pad to 2 digits
        local day=$(printf "%02d" "$arg1")
        local current_month=$(date +%Y-%m)
        local target_date="${current_month}-${day}"
        local daily_file="$BJ_DIR/${target_date}.md"

        if [[ ! -f "$daily_file" ]]; then
            echo "[Daily] $(show_date_header "$target_date")"
            echo "No tasks."
            return 0
        fi

        echo "[Daily] $(show_date_header "$target_date")"
        local entries
        entries=$(grep -v "^#" "$daily_file" | grep -v "^$" || true)

        if [[ -z "$entries" ]]; then
            echo "No tasks."
        else
            echo "$entries" | sed 's/^[[:space:]]*//'
        fi
        return 0
    fi

    # Check if arg1 is a month name
    local month_num
    month_num=$(get_month_number "$arg1")

    if [[ -n "$month_num" ]]; then
        local year="${arg2:-$(date +%Y)}"
        local target_month="${year}-${month_num}"
        local monthly_file="$BJ_DIR/${target_month}.md"

        if [[ ! -f "$monthly_file" ]]; then
            echo "[Monthly] $(show_month_header "$target_month")"
            echo "No monthly logs."
            return 0
        fi

        echo "[Monthly] $(show_month_header "$target_month")"
        local entries
        entries=$(grep -v "^#" "$monthly_file" | grep -v "^$" || true)

        if [[ -z "$entries" ]]; then
            echo "No monthly logs."
        else
            echo "$entries" | sed 's/^[[:space:]]*//'
        fi
        return 0
    fi

    # Invalid argument
    echo "Error: Invalid list argument '$arg1'" >&2
    echo "Usage: bj list DD | bj list MONTH [YEAR] | bj list future [YEAR]" >&2
    echo "Examples: bj list 01, bj list dec, bj list dec 2026, bj list future 2026" >&2
    exit 1
}

# Add task
add() {
    local bullet="$1"
    shift
    local text="$*"

    # Validate bullet type for adding
    if [[ ! "$bullet" =~ ^${ADD_BULLET_PATTERN}$ ]]; then
        echo "Error: Invalid bullet '$bullet' for adding tasks" >&2
        echo "Valid bullets for adding: . (task), ! (priority), o (event), - (note)" >&2
        exit 1
    fi

    # Validate task text is not empty
    if [[ -z "$text" ]]; then
        echo "Error: Task text cannot be empty" >&2
        exit 1
    fi

    echo "$bullet  $text" >> "$FILE"
    echo "$bullet  $text"
}

# Change bullet
change() {
    local new_bullet="$1"
    local num="$2"

    # Validate bullet type for changing
    if [[ ! "$new_bullet" =~ ^${CHANGE_BULLET_PATTERN}$ ]]; then
        echo "Error: Invalid bullet '$new_bullet' for changing task status" >&2
        echo "Valid bullets for changing: ! (priority), x (done), o (event), a (abandoned), w (waiting), - (note)" >&2
        exit 1
    fi

    local actual_line
    actual_line=$(get_task_line "$num") || exit 1

    # Get current task and show what will change
    local old_line
    old_line=$(sed -n "${actual_line}p" "$FILE")

    # Preview the change
    local task_text
    task_text=$(echo "$old_line" | sed -E "s/^[[:space:]]*${BULLET_PATTERN}[[:space:]]*//" )
    local new_preview="$new_bullet  $task_text"

    echo "Change: $old_line"
    echo "To:     $new_preview"
    read -p "Are you sure? (y/N): " -n 1 -r
    echo

    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "Cancelled."
        exit 0
    fi

    # Change the bullet - strip leading spaces and ensure consistent format
    sed_inplace "${actual_line}s/^[[:space:]]*${BULLET_PATTERN}/$new_bullet/" "$FILE"

    local new_line
    new_line=$(sed -n "${actual_line}p" "$FILE")
    echo "Changed: $new_line"
}

# Delete task
delete() {
    local num="$1"

    local actual_line
    actual_line=$(get_task_line "$num") || exit 1

    local to_delete
    to_delete=$(sed -n "${actual_line}p" "$FILE")

    # Show task and ask for confirmation
    echo "Delete: $to_delete"
    read -p "Are you sure? (y/N): " -n 1 -r
    echo

    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "Cancelled."
        exit 0
    fi

    sed_inplace "${actual_line}d" "$FILE"
    echo "Deleted."
}

# Navigate to date
navigate() {
    local date_arg="$1"

    local target_date
    target_date=$(parse_date "$date_arg") || exit 1

    validate_date "$target_date" || exit 1

    set_current_date "$target_date"
    set_current_mode "daily"

    local target_file="$BJ_DIR/$target_date.md"
    ensure_file "$target_file" "$target_date"

    # Update FILE variable for list function
    FILE="$target_file"
    CURRENT_DATE="$target_date"
    CURRENT_MODE="daily"

    # Show date header and tasks
    show_date_header "$target_date"

    local entries
    entries=$(grep -v "^#" "$target_file" | grep -v "^$" || true)

    if [[ -z "$entries" ]]; then
        echo "No tasks."
    else
        # Strip leading spaces for consistent alignment
        echo "$entries" | sed 's/^[[:space:]]*//'
    fi
}

# Goto navigation with flexible date parsing
goto_navigation() {
    local arg1="${1:-}"
    local arg2="${2:-}"
    local arg3="${3:-}"

    # Case 1: goto today or no args
    if [[ -z "$arg1" ]] || [[ "$arg1" == "today" ]]; then
        local today_date=$(date +%Y-%m-%d)
        set_current_date "$today_date"
        set_current_mode "daily"

        local target_file="$BJ_DIR/$today_date.md"
        ensure_file "$target_file" "$today_date"

        FILE="$target_file"
        CURRENT_DATE="$today_date"
        CURRENT_MODE="daily"

        show_date_header "$today_date"
        local entries
        entries=$(grep -v "^#" "$target_file" | grep -v "^$" || true)
        if [[ -z "$entries" ]]; then
            echo "No tasks."
        else
            echo "$entries" | sed 's/^[[:space:]]*//'
        fi
        return 0
    fi

    # Case 2: goto DD (day in current month)
    if [[ "$arg1" =~ ^[0-9]{1,2}$ ]] && [[ -z "$arg2" ]]; then
        local day=$(printf "%02d" "$arg1")
        local current_month=$(date +%Y-%m)
        local target_date="${current_month}-${day}"

        validate_date "$target_date" || exit 1

        set_current_date "$target_date"
        set_current_mode "daily"

        local target_file="$BJ_DIR/$target_date.md"
        ensure_file "$target_file" "$target_date"

        FILE="$target_file"
        CURRENT_DATE="$target_date"
        CURRENT_MODE="daily"

        show_date_header "$target_date"
        local entries
        entries=$(grep -v "^#" "$target_file" | grep -v "^$" || true)
        if [[ -z "$entries" ]]; then
            echo "No tasks."
        else
            echo "$entries" | sed 's/^[[:space:]]*//'
        fi
        return 0
    fi

    # Check if arg1 is a month name
    local month_num
    month_num=$(get_month_number "$arg1")

    if [[ -n "$month_num" ]]; then
        # Case 3: goto MONTH (monthly log)
        if [[ -z "$arg2" ]]; then
            local year=$(date +%Y)
            local target_month="${year}-${month_num}"

            set_current_month "$target_month"
            set_current_mode "monthly"

            local target_file="$BJ_DIR/$target_month.md"
            ensure_file "$target_file" "$target_month"

            FILE="$target_file"
            CURRENT_MONTH="$target_month"
            CURRENT_MODE="monthly"

            echo "[Monthly] $(show_month_header "$target_month")"
            local entries
            entries=$(grep -v "^#" "$target_file" | grep -v "^$" || true)
            if [[ -z "$entries" ]]; then
                echo "No monthly logs."
            else
                echo "$entries" | sed 's/^[[:space:]]*//'
            fi
            return 0
        fi

        # Case 4: goto MONTH DD [YEAR] (daily log)
        if [[ "$arg2" =~ ^[0-9]{1,2}$ ]]; then
            local day=$(printf "%02d" "$arg2")
            local year="${arg3:-$(date +%Y)}"
            local target_date="${year}-${month_num}-${day}"

            validate_date "$target_date" || exit 1

            set_current_date "$target_date"
            set_current_mode "daily"

            local target_file="$BJ_DIR/$target_date.md"
            ensure_file "$target_file" "$target_date"

            FILE="$target_file"
            CURRENT_DATE="$target_date"
            CURRENT_MODE="daily"

            show_date_header "$target_date"
            local entries
            entries=$(grep -v "^#" "$target_file" | grep -v "^$" || true)
            if [[ -z "$entries" ]]; then
                echo "No tasks."
            else
                echo "$entries" | sed 's/^[[:space:]]*//'
            fi
            return 0
        fi
    fi

    # Invalid arguments
    echo "Error: Invalid goto arguments" >&2
    echo "Usage: bj goto [today|DD|MONTH|MONTH DD [YEAR]]" >&2
    echo "Examples: bj goto today, bj goto 01, bj goto dec, bj goto dec 01, bj goto dec 01 2026" >&2
    exit 1
}

# Migrate tasks
migrate() {
    local arg1="${1:-}"
    local arg2="${2:-}"
    local arg3="${3:-}"

    # Check if we're in daily mode
    if [[ "$CURRENT_MODE" != "daily" ]]; then
        echo "Error: Migration only works in daily mode" >&2
        exit 1
    fi

    # Case 1: migrate * MONTH YEAR - Migrate all tasks from current month to monthly log
    if [[ "$arg1" == "*" ]] && [[ -n "$arg2" ]]; then
        local month_num
        month_num=$(get_month_number "$arg2")

        if [[ -z "$month_num" ]]; then
            echo "Error: Invalid month '$arg2'" >&2
            exit 1
        fi

        local year="${arg3:-$(date +%Y)}"
        local target_month="${year}-${month_num}"
        local target_file="$BJ_DIR/$target_month.md"
        ensure_file "$target_file" "$target_month"

        # Get current month
        local current_month="${CURRENT_DATE:0:7}"
        local month_files
        month_files=$(ls "$BJ_DIR/$current_month"-*.md 2>/dev/null || true)

        if [[ -z "$month_files" ]]; then
            echo "No daily log files found for $current_month."
            exit 0
        fi

        # Collect all incomplete tasks from all days in current month
        local all_incomplete=""
        local files_with_tasks=()

        while IFS= read -r file; do
            if [[ -z "$file" ]]; then
                continue
            fi

            local incomplete
            incomplete=$(grep -E "^[[:space:]]*${INCOMPLETE_PATTERN}[[:space:]]" "$file" || true)

            if [[ -n "$incomplete" ]]; then
                all_incomplete="${all_incomplete}${incomplete}"$'\n'
                files_with_tasks+=("$file")
            fi
        done <<< "$month_files"

        all_incomplete=$(echo "$all_incomplete" | sed '/^$/d')

        if [[ -z "$all_incomplete" ]]; then
            echo "No incomplete tasks to migrate from $current_month."
            exit 0
        fi

        echo "Migrating incomplete tasks from $current_month to $(show_month_header "$target_month") monthly log:"
        echo "$all_incomplete"
        echo ""

        # Append to target file
        echo "$all_incomplete" >> "$target_file"

        # Update source files - mark as migrated
        for file in "${files_with_tasks[@]}"; do
            local incomplete
            incomplete=$(grep -E "^[[:space:]]*${INCOMPLETE_PATTERN}[[:space:]]" "$file" || true)

            while IFS= read -r line; do
                if [[ -n "$line" ]]; then
                    local escaped_line
                    escaped_line=$(printf '%s\n' "$line" | sed 's/[]\/$*.^[]/\\&/g')
                    local text_part
                    text_part=$(echo "$line" | sed -E "s/^[[:space:]]*${INCOMPLETE_PATTERN}[[:space:]]*//")
                    sed_inplace "s/^${escaped_line}$/${BULLET_MIGRATED}  ${text_part}/" "$file"
                fi
            done <<< "$incomplete"
        done

        echo "Migrated to $(show_month_header "$target_month") monthly log!"
        return 0
    fi

    # Case 2: migrate N MONTH - Migrate task N to monthly log
    if [[ "$arg1" =~ ^[0-9]+$ ]] && [[ -n "$arg2" ]]; then
        local month_num
        month_num=$(get_month_number "$arg2")

        if [[ -z "$month_num" ]]; then
            echo "Error: Invalid month '$arg2'" >&2
            exit 1
        fi

        local year=$(date +%Y)
        local target_month="${year}-${month_num}"
        local target_file="$BJ_DIR/$target_month.md"
        ensure_file "$target_file" "$target_month"

        # Get the task line
        local actual_line
        actual_line=$(get_task_line "$arg1") || exit 1
        local task_content
        task_content=$(sed -n "${actual_line}p" "$FILE")

        # Check if task is incomplete
        if ! echo "$task_content" | grep -qE "^[[:space:]]*${INCOMPLETE_PATTERN}[[:space:]]"; then
            echo "Error: Task $arg1 is not incomplete (must be ., !, or w)" >&2
            exit 1
        fi

        echo "Migrating task $arg1 to $(show_month_header "$target_month") monthly log:"
        echo "$task_content"

        # Append to target file
        echo "$task_content" >> "$target_file"

        # Update source file - mark as migrated
        local escaped_line
        escaped_line=$(printf '%s\n' "$task_content" | sed 's/[]\/$*.^[]/\\&/g')
        local text_part
        text_part=$(echo "$task_content" | sed -E "s/^[[:space:]]*${INCOMPLETE_PATTERN}[[:space:]]*//")
        sed_inplace "s/^${escaped_line}$/${BULLET_MIGRATED}  ${text_part}/" "$FILE"

        echo "Migrated to $(show_month_header "$target_month") monthly log!"
        return 0
    fi

    # Case 3: migrate N - Migrate task N to next working day
    if [[ "$arg1" =~ ^[0-9]+$ ]] && [[ -z "$arg2" ]]; then
        local next_day
        next_day=$(get_next_working_day "$CURRENT_DATE")
        local target_file="$BJ_DIR/$next_day.md"
        ensure_file "$target_file" "$next_day"

        # Get the task line
        local actual_line
        actual_line=$(get_task_line "$arg1") || exit 1
        local task_content
        task_content=$(sed -n "${actual_line}p" "$FILE")

        # Check if task is incomplete
        if ! echo "$task_content" | grep -qE "^[[:space:]]*${INCOMPLETE_PATTERN}[[:space:]]"; then
            echo "Error: Task $arg1 is not incomplete (must be ., !, or w)" >&2
            exit 1
        fi

        echo "Migrating task $arg1 to $(show_date_header "$next_day"):"
        echo "$task_content"

        # Append to target file
        echo "$task_content" >> "$target_file"

        # Update source file - mark as migrated
        local escaped_line
        escaped_line=$(printf '%s\n' "$task_content" | sed 's/[]\/$*.^[]/\\&/g')
        local text_part
        text_part=$(echo "$task_content" | sed -E "s/^[[:space:]]*${INCOMPLETE_PATTERN}[[:space:]]*//")
        sed_inplace "s/^${escaped_line}$/${BULLET_MIGRATED}  ${text_part}/" "$FILE"

        echo "Migrated to $(show_date_header "$next_day")!"
        return 0
    fi

    # Case 4: migrate or migrate * - Migrate all tasks to next working day
    if [[ -z "$arg1" ]] || [[ "$arg1" == "*" ]] && [[ -z "$arg2" ]]; then
        local next_day
        next_day=$(get_next_working_day "$CURRENT_DATE")
        local target_file="$BJ_DIR/$next_day.md"
        ensure_file "$target_file" "$next_day"

        # Get all incomplete tasks
        local incomplete
        incomplete=$(grep -E "^[[:space:]]*${INCOMPLETE_PATTERN}[[:space:]]" "$FILE" || true)

        if [[ -z "$incomplete" ]]; then
            echo "No incomplete tasks to migrate."
            exit 0
        fi

        echo "Migrating all incomplete tasks to $(show_date_header "$next_day"):"
        echo "$incomplete"
        echo ""

        # Append to target file
        echo "$incomplete" >> "$target_file"

        # Update source file - mark as migrated
        while IFS= read -r line; do
            if [[ -n "$line" ]]; then
                local escaped_line
                escaped_line=$(printf '%s\n' "$line" | sed 's/[]\/$*.^[]/\\&/g')
                local text_part
                text_part=$(echo "$line" | sed -E "s/^[[:space:]]*${INCOMPLETE_PATTERN}[[:space:]]*//")
                sed_inplace "s/^${escaped_line}$/${BULLET_MIGRATED}  ${text_part}/" "$FILE"
            fi
        done <<< "$incomplete"

        echo "Migrated to $(show_date_header "$next_day")!"
        return 0
    fi

    echo "Error: Invalid migrate arguments" >&2
    echo "Usage:" >&2
    echo "  bj migrate              # Migrate all tasks to next working day" >&2
    echo "  bj migrate *            # Migrate all tasks to next working day" >&2
    echo "  bj migrate N            # Migrate task N to next working day" >&2
    echo "  bj migrate N MONTH      # Migrate task N to MONTH monthly log" >&2
    echo "  bj migrate * MONTH YEAR # Migrate all tasks from current month to MONTH YEAR monthly log" >&2
    exit 1
}

# Schedule task to specific date
schedule() {
    local num="$1"
    local month_arg="$2"
    local year_arg="${3:-}"

    # Parse month name to month number
    local target_month
    target_month=$(get_month_number "$month_arg")

    if [[ -z "$target_month" ]]; then
        echo "Error: Invalid month '$month_arg'" >&2
        echo "Use month name (e.g., dec, january) or short form (jan, feb, etc.)" >&2
        exit 1
    fi

    # Use provided year or current year
    local target_year
    if [[ -n "$year_arg" ]]; then
        if [[ ! "$year_arg" =~ ^[0-9]{4}$ ]]; then
            echo "Error: Invalid year '$year_arg' (must be 4 digits)" >&2
            exit 1
        fi
        target_year="$year_arg"
    else
        target_year="$(date +%Y)"
    fi

    # Get the task line
    local actual_line
    actual_line=$(get_task_line "$num") || exit 1

    # Get the task line with bullet
    local task_line
    task_line=$(sed -n "${actual_line}p" "$FILE")

    # Extract bullet type
    local bullet_type
    bullet_type=$(echo "$task_line" | sed -E "s/^[[:space:]]*([.!xoaw><-])[[:space:]].*/\1/")

    # Extract task text
    local task_text
    task_text=$(echo "$task_line" | sed -E "s/^[[:space:]]*${BULLET_PATTERN}[[:space:]]*//")

    # Check if task already scheduled
    if [[ "$task_text" =~ ^[0-9]{4}-[0-9]{2}:[[:space:]] ]]; then
        echo "Task already scheduled: ${BULLET_SCHEDULED}  $task_text"
        exit 0
    fi

    # Create future log file if needed
    local target_file="$BJ_DIR/${target_year}.md"
    ensure_file "$target_file" "$target_year"

    # Get month name
    local month_name
    month_name=$(get_month_name "$target_month")

    # Add task to month section with original bullet type
    add_to_month_section "$target_file" "$month_name" "${bullet_type}  ${task_text}"

    # Format target date as YYYY-MM
    local target_date="${target_year}-${target_month}"

    # Change bullet to < and add timestamp in current file
    sed_inplace "${actual_line}s/^[[:space:]]*[.!xoaw><-][[:space:]]*/${BULLET_SCHEDULED}  ${target_date}: /" "$FILE"

    echo "Scheduled to $month_name $target_year: ${BULLET_SCHEDULED}  ${target_date}: ${task_text}"
}

# Search tasks
search() {
    # Temporarily disable set -e for this function
    set +e

    local pattern="$1"
    local month_arg="${2:-}"
    local year_arg="${3:-}"

    # Check if pattern is a bullet type
    local is_bullet=false
    case "$pattern" in
        .|!|x|o|a|w|\>|\<|-)
            is_bullet=true
            ;;
    esac

    # Determine scope
    local search_year=""
    local search_month=""

    if [[ -n "$year_arg" ]]; then
        if [[ ! "$year_arg" =~ ^[0-9]{4}$ ]]; then
            echo "Error: Invalid year '$year_arg' (must be 4 digits)" >&2
            exit 1
        fi
        search_year="$year_arg"
    fi

    if [[ -n "$month_arg" ]]; then
        if [[ "$month_arg" == "*" ]]; then
            # Search all months
            search_month="*"
        else
            # Parse month name
            local month_num
            month_num=$(get_month_number "$month_arg")
            if [[ -z "$month_num" ]]; then
                echo "Error: Invalid month '$month_arg'" >&2
                exit 1
            fi
            search_month="$month_num"
            # Default to current year if month is specified but year is not
            if [[ -z "$search_year" ]]; then
                search_year=$(date +%Y)
            fi
        fi
    fi

    local found_count=0

    # Search in daily logs
    if [[ -n "$search_month" ]] || [[ -z "$month_arg" ]]; then
        if [[ -n "$search_year" ]] && [[ -n "$search_month" ]] && [[ "$search_month" != "*" ]]; then
            # Search specific month in specific year
            local files
            files=$(ls "$BJ_DIR/${search_year}-${search_month}"-*.md 2>/dev/null || true)
        elif [[ -n "$search_year" ]] && [[ "$search_month" == "*" ]]; then
            # Search all months in specific year
            local files
            files=$(ls "$BJ_DIR/${search_year}"-*-*.md 2>/dev/null || true)
        elif [[ -z "$month_arg" ]] && [[ -z "$year_arg" ]]; then
            # Search all daily logs
            local files
            files=$(ls "$BJ_DIR"/????-??-??.md 2>/dev/null || true)
        else
            local files=""
        fi

        if [[ -n "$files" ]]; then
            # Process each file - use for loop with IFS
            IFS=$'\n'
            for file in $files; do
                if [[ -z "$file" ]]; then
                    continue
                fi

                # Extract date from filename (YYYY-MM-DD.md)
                filename=$(basename "$file" .md)

                # Read file line by line and check for matches
                while IFS= read -r line || [[ -n "$line" ]]; do
                    # Skip headers and empty lines
                    if [[ -z "$line" ]] || [[ "$line" =~ ^# ]]; then
                        continue
                    fi

                    # Check if line matches
                    match=false
                    if [[ "$is_bullet" == true ]]; then
                        # Check if line starts with the bullet
                        if echo "$line" | grep -qE "^[[:space:]]*${pattern}[[:space:]]"; then
                            match=true
                        fi
                    else
                        # Case-insensitive text search
                        if echo "$line" | grep -qi "$pattern"; then
                            match=true
                        fi
                    fi

                    if [[ "$match" == true ]]; then
                        echo "D:${filename}     ${line}" | sed 's/^[[:space:]]*//' | sed 's/  */ /g'
                        ((found_count++))
                    fi
                done < "$file"
            done
        fi
    fi

    # Search in monthly logs
    if [[ -z "$month_arg" ]] || [[ -n "$search_month" ]]; then
        if [[ -n "$search_year" ]] && [[ -n "$search_month" ]] && [[ "$search_month" != "*" ]]; then
            # Search specific month in specific year
            local files="$BJ_DIR/${search_year}-${search_month}.md"
            if [[ ! -f "$files" ]]; then
                files=""
            fi
        elif [[ -n "$search_year" ]] && [[ "$search_month" == "*" ]]; then
            # Search all months in specific year
            local files
            files=$(ls "$BJ_DIR/${search_year}"-??.md 2>/dev/null || true)
        elif [[ -z "$month_arg" ]] && [[ -z "$year_arg" ]]; then
            # Search all monthly logs
            local files
            files=$(ls "$BJ_DIR"/????-??.md 2>/dev/null || true)
        else
            local files=""
        fi

        if [[ -n "$files" ]]; then
            # Process each file - use for loop with IFS
            IFS=$'\n'
            for file in $files; do
                if [[ -z "$file" ]] || [[ ! -f "$file" ]]; then
                    continue
                fi

                # Extract YYYY-MM from filename
                filename=$(basename "$file" .md)
                year="${filename:0:4}"
                month="${filename:5:2}"
                month_name=$(get_month_name "$month")

                # Read file line by line and check for matches
                while IFS= read -r line || [[ -n "$line" ]]; do
                    # Skip headers and empty lines
                    if [[ -z "$line" ]] || [[ "$line" =~ ^# ]]; then
                        continue
                    fi

                    # Check if line matches
                    match=false
                    if [[ "$is_bullet" == true ]]; then
                        if echo "$line" | grep -qE "^[[:space:]]*${pattern}[[:space:]]"; then
                            match=true
                        fi
                    else
                        if echo "$line" | grep -qi "$pattern"; then
                            match=true
                        fi
                    fi

                    if [[ "$match" == true ]]; then
                        echo "M:${month_name:0:3}-${year}     ${line}" | sed 's/^[[:space:]]*//' | sed 's/  */ /g'
                        ((found_count++))
                    fi
                done < "$file"
            done
        fi
    fi

    # Search in future logs
    if [[ -z "$month_arg" ]] || [[ "$search_month" == "*" ]]; then
        if [[ -n "$search_year" ]]; then
            # Search specific year future log
            local files="$BJ_DIR/${search_year}.md"
            if [[ ! -f "$files" ]]; then
                files=""
            fi
        else
            # Search all future logs
            local files
            files=$(ls "$BJ_DIR"/????.md 2>/dev/null || true)
        fi

        if [[ -n "$files" ]]; then
            # Process each file - use for loop with IFS
            IFS=$'\n'
            for file in $files; do
                if [[ -z "$file" ]] || [[ ! -f "$file" ]]; then
                    continue
                fi

                # Extract year from filename
                year=$(basename "$file" .md)

                # Read file and track current month section
                current_month=""
                while IFS= read -r line || [[ -n "$line" ]]; do
                    # Check if this is a month header
                    if [[ "$line" =~ ^\[([A-Z]+)\]$ ]]; then
                        current_month="${BASH_REMATCH[1]}"
                        continue
                    fi

                    # Skip empty lines and file headers
                    [[ -z "$line" ]] && continue
                    [[ "$line" =~ ^# ]] && continue

                    # Search in task line
                    match=false
                    if [[ "$is_bullet" == true ]]; then
                        if echo "$line" | grep -qE "^[[:space:]]*${pattern}[[:space:]]"; then
                            match=true
                        fi
                    else
                        if echo "$line" | grep -qi "$pattern"; then
                            match=true
                        fi
                    fi

                    if [[ "$match" == true ]] && [[ -n "$current_month" ]]; then
                        echo "F:${current_month:0:3}-${year}     ${line}" | sed 's/^[[:space:]]*//' | sed 's/  */ /g'
                        ((found_count++))
                    fi
                done < "$file"
            done
        fi
    fi

    if [[ $found_count -eq 0 ]]; then
        echo "No matches found."
    else
        echo ""
        echo "Found $found_count match(es)."
    fi

    # Re-enable set -e
    set -e
}

# Switch write mode
write_mode() {
    local mode="$1"

    if [[ "$mode" != "daily" ]] && [[ "$mode" != "monthly" ]] && [[ "$mode" != "future" ]]; then
        echo "Error: Invalid mode '$mode'" >&2
        echo "Valid modes: daily, monthly, future" >&2
        exit 1
    fi

    set_current_mode "$mode"

    if [[ "$mode" == "monthly" ]]; then
        echo "Switched to monthly log mode"
        # Initialize current month if not set
        CURRENT_MONTH=$(get_current_month)
        FILE="$BJ_DIR/$CURRENT_MONTH.md"
        ensure_file "$FILE" "$CURRENT_MONTH"
        CURRENT_MODE="monthly"
    elif [[ "$mode" == "future" ]]; then
        echo "Switched to future log mode"
        # Initialize current year if not set
        CURRENT_YEAR=$(get_current_year)
        FILE="$BJ_DIR/$CURRENT_YEAR.md"
        ensure_file "$FILE" "$CURRENT_YEAR"
        CURRENT_MODE="future"
    else
        echo "Switched to daily log mode"
        # Re-initialize to current date
        CURRENT_DATE=$(get_current_date)
        FILE="$BJ_DIR/$CURRENT_DATE.md"
        ensure_file "$FILE" "$CURRENT_DATE"
        CURRENT_MODE="daily"
    fi

    # Show current context
    list
}

# Workspace management
workspace_cmd() {
    local subcmd="${1:-}"
    local workspace_name="${2:-}"

    case "$subcmd" in
        "")
            # Show current workspace
            local current=$(get_current_workspace)
            echo "Current workspace: $current"
            ;;
        list)
            # List all workspaces
            echo "Available workspaces:"
            for dir in "$BJ_ROOT"/*/; do
                if [[ -d "$dir" ]]; then
                    local ws=$(basename "$dir")
                    local current=$(get_current_workspace)
                    if [[ "$ws" == "$current" ]]; then
                        echo "* $ws (current)"
                    else
                        echo "  $ws"
                    fi
                fi
            done
            ;;
        new)
            # Create new workspace
            if [[ -z "$workspace_name" ]]; then
                echo "Error: Workspace name required" >&2
                echo "Usage: bj workspace new <name>" >&2
                exit 1
            fi

            local ws_dir="$BJ_ROOT/$workspace_name"
            if [[ -d "$ws_dir" ]]; then
                echo "Workspace '$workspace_name' already exists"
            else
                mkdir -p "$ws_dir"
                echo "Created workspace: $workspace_name"
            fi
            ;;
        *)
            # Switch to workspace (create if doesn't exist)
            workspace_name="$subcmd"

            if [[ -z "$workspace_name" ]]; then
                echo "Error: Workspace name required" >&2
                echo "Usage: bj workspace <name>" >&2
                exit 1
            fi

            local ws_dir="$BJ_ROOT/$workspace_name"
            if [[ ! -d "$ws_dir" ]]; then
                mkdir -p "$ws_dir"
                echo "Created new workspace: $workspace_name"
            fi

            set_current_workspace "$workspace_name"
            echo "Switched to workspace: $workspace_name"
            ;;
    esac
}

# Show help
help() {
    cat <<'EOF'
bj - Minimal Bullet Journal

USAGE:
  bj                  List tasks in current write mode
  bj list DD          List daily log for day DD of current month
  bj list MONTH       List monthly log for MONTH of current year
  bj list MONTH YEAR  List monthly log for MONTH of YEAR
  bj list future      List future log for current year
  bj list future YEAR List future log for YEAR
  bj [text]           Add task (default: .)
  bj [bullet] [text]  Add task with bullet
  bj [bullet] [n]     Change task n to bullet
  bj del [n]          Delete task n
  bj goto today       Go to today
  bj goto DD          Go to day DD of current month
  bj goto MONTH       Go to MONTH of current year (monthly log)
  bj goto MONTH DD    Go to MONTH DD of current year
  bj goto MONTH DD YEAR Go to MONTH DD of YEAR
  bj migrate          Migrate incomplete tasks from current month to next month
  bj schedule [n] MONTH [YEAR]  Schedule task n to future log month
  bj search PATTERN [MONTH|*] [YEAR]  Search for tasks
  bj write daily      Switch to daily log mode
  bj write monthly    Switch to monthly log mode
  bj write future     Switch to future log mode
  bj workspace        Show current workspace
  bj workspace list   List all workspaces
  bj workspace new <name>  Create new workspace
  bj workspace <name> Switch to workspace (creates if doesn't exist)

BULLETS:
  .  task     x  done      a  abandoned
  !  priority o  event     -  note
  w  waiting  >  migrated  <  scheduled

EXAMPLES:
  bj                  # List tasks in current mode
  bj list 01          # List daily log for Dec 1st
  bj list dec         # List monthly log for December
  bj list dec 2026    # List monthly log for December 2026
  bj list future      # List future log for current year
  bj list future 2026 # List future log for 2026
  bj Buy milk         # Add task ". Buy milk"
  bj o Meeting at 3pm # Add event
  bj x 1              # Mark task 1 as done
  bj del 3            # Delete task 3
  bj goto today       # Go to today
  bj goto 01          # Go to day 1 of current month
  bj goto dec         # Go to December (monthly log)
  bj goto dec 25      # Go to December 25
  bj goto dec 25 2026 # Go to December 25, 2026
  bj migrate          # Migrate all incomplete tasks to next month
  bj schedule 2 dec   # Schedule task 2 to December (future log)
  bj schedule 3 jan 2026 # Schedule task 3 to January 2026 (future log)
  bj search migration # Search for "migration" in all logs
  bj search ! dec     # Search for priority tasks in December daily logs
  bj search x         # Search for completed tasks in all logs
  bj write monthly    # Switch to monthly logs
  bj write future     # Switch to future log
  bj write daily      # Switch back to daily logs
  bj workspace        # Show current workspace
  bj workspace list   # List all workspaces
  bj workspace work   # Switch to work workspace
  bj workspace new personal  # Create personal workspace
EOF
}

# Main
if [[ $# -eq 0 ]]; then
    list
    exit 0
fi

case "$1" in
    -h|--help|help)
        help
        exit 0
        ;;
    -v|--version|version)
        echo "bj version $VERSION"
        exit 0
        ;;
    list)
        if [[ $# -lt 2 ]] || [[ $# -gt 3 ]]; then
            echo "Usage: bj list DD | bj list MONTH [YEAR] | bj list future [YEAR]"
            exit 1
        fi
        list_logs "$2" "${3:-}"
        exit 0
        ;;
    del)
        if [[ $# -ne 2 ]]; then
            echo "Usage: bj del [n]"
            exit 1
        fi
        delete "$2"
        exit 0
        ;;
    date)
        if [[ $# -ne 2 ]]; then
            echo "Usage: bj date today | bj date MMDD | bj date YYYYMMDD"
            exit 1
        fi
        navigate "$2"
        exit 0
        ;;
    goto)
        if [[ $# -lt 1 ]] || [[ $# -gt 4 ]]; then
            echo "Usage: bj goto [today|DD|MONTH|MONTH DD [YEAR]]"
            exit 1
        fi
        goto_navigation "${2:-}" "${3:-}" "${4:-}"
        exit 0
        ;;
    migrate)
        if [[ $# -lt 1 ]] || [[ $# -gt 4 ]]; then
            echo "Usage: bj migrate [*|N] [MONTH] [YEAR]"
            exit 1
        fi
        migrate "${2:-}" "${3:-}" "${4:-}"
        exit 0
        ;;
    schedule)
        if [[ $# -lt 3 ]] || [[ $# -gt 4 ]]; then
            echo "Usage: bj schedule [n] MONTH [YEAR]"
            exit 1
        fi
        schedule "$2" "$3" "${4:-}"
        exit 0
        ;;
    search)
        if [[ $# -lt 2 ]] || [[ $# -gt 4 ]]; then
            echo "Usage: bj search PATTERN [MONTH|*] [YEAR]"
            exit 1
        fi
        search "$2" "${3:-}" "${4:-}"
        exit 0
        ;;
    write)
        if [[ $# -ne 2 ]]; then
            echo "Usage: bj write daily | bj write monthly"
            exit 1
        fi
        write_mode "$2"
        exit 0
        ;;
    workspace)
        workspace_cmd "${2:-}" "${3:-}"
        exit 0
        ;;
    .)
        # bj . some task
        add . "${@:2}"
        exit 0
        ;;
    "!"|o|-)
        # Could be: bj ! 1 (change) or bj ! some text (add)
        if [[ $# -eq 2 ]] && [[ "$2" =~ ^[0-9]+$ ]]; then
            change "$1" "$2"
        else
            add "$1" "${@:2}"
        fi
        exit 0
        ;;
    x|a|w)
        # Only for changing status: bj x 1
        if [[ $# -ne 2 ]]; then
            echo "Usage: bj $1 [n]" >&2
            exit 1
        fi
        if [[ ! "$2" =~ ^[0-9]+$ ]]; then
            echo "Error: Bullet '$1' can only be used for changing task status, not adding tasks" >&2
            echo "Usage: bj $1 [task_number]" >&2
            exit 1
        fi
        change "$1" "$2"
        exit 0
        ;;
    *)
        # Check if first argument looks like an invalid bullet attempt
        if [[ ${#1} -eq 1 ]] && [[ ! "$1" =~ ^${ADD_BULLET_PATTERN}$ ]]; then
            echo "Error: Invalid bullet '$1' for adding tasks" >&2
            echo "Valid bullets for adding: . (task), ! (priority), o (event), - (note)" >&2
            exit 1
        fi
        # bj some text - add as task
        add . "$@"
        exit 0
        ;;
esac
