#!/bin/bash
#
# bj - Minimal Bullet Journal
# Version: 1.0.0

set -euo pipefail

# Constants
readonly VERSION="1.0.0"
readonly BJ_DIR="${BJ_HOME:-$HOME/bj}"
readonly CACHE_FILE="$BJ_DIR/.current_date"
readonly CACHE_MODE="$BJ_DIR/.current_mode"
readonly CACHE_MONTH="$BJ_DIR/.current_month"
readonly CACHE_YEAR="$BJ_DIR/.current_year"

# Bullet type constants
readonly BULLET_TASK="."
readonly BULLET_PRIORITY="!"
readonly BULLET_DONE="x"
readonly BULLET_EVENT="o"
readonly BULLET_ABANDONED="a"
readonly BULLET_WAITING="w"
readonly BULLET_MIGRATED=">"
readonly BULLET_SCHEDULED="<"
readonly BULLET_NOTE="-"

# Regex patterns
readonly BULLET_PATTERN='[.!xoaw><-]'
readonly INCOMPLETE_PATTERN='[.!w]'
readonly ADD_BULLET_PATTERN='[.!o-]'
readonly CHANGE_BULLET_PATTERN='[!xoaw-]'

mkdir -p "$BJ_DIR"

# Get current working date
get_current_date() {
    if [[ -f "$CACHE_FILE" ]]; then
        cat "$CACHE_FILE"
    else
        date +%Y-%m-%d
    fi
}

# Set current working date
set_current_date() {
    echo "$1" > "$CACHE_FILE"
}

# Get current mode (daily/monthly)
get_current_mode() {
    if [[ -f "$CACHE_MODE" ]]; then
        cat "$CACHE_MODE"
    else
        echo "daily"
    fi
}

# Set current mode
set_current_mode() {
    echo "$1" > "$CACHE_MODE"
}

# Get current working month
get_current_month() {
    if [[ -f "$CACHE_MONTH" ]]; then
        cat "$CACHE_MONTH"
    else
        date +%Y-%m
    fi
}

# Set current working month
set_current_month() {
    echo "$1" > "$CACHE_MONTH"
}

# Get current working year
get_current_year() {
    if [[ -f "$CACHE_YEAR" ]]; then
        cat "$CACHE_YEAR"
    else
        date +%Y
    fi
}

# Set current working year
set_current_year() {
    echo "$1" > "$CACHE_YEAR"
}

CURRENT_DATE=$(get_current_date)
CURRENT_MODE=$(get_current_mode)
CURRENT_MONTH=$(get_current_month)
CURRENT_YEAR=$(get_current_year)

# Set FILE based on mode
if [[ "$CURRENT_MODE" == "monthly" ]]; then
    FILE="$BJ_DIR/$CURRENT_MONTH.md"
elif [[ "$CURRENT_MODE" == "future" ]]; then
    FILE="$BJ_DIR/$CURRENT_YEAR.md"
else
    FILE="$BJ_DIR/$CURRENT_DATE.md"
fi

# Create file if needed
if [[ ! -f "$FILE" ]]; then
    if [[ "$CURRENT_MODE" == "monthly" ]]; then
        echo "# $CURRENT_MONTH" > "$FILE"
    elif [[ "$CURRENT_MODE" == "future" ]]; then
        echo "# $CURRENT_YEAR" > "$FILE"
    else
        echo "# $CURRENT_DATE" > "$FILE"
    fi
    echo "" >> "$FILE"
fi

# Portable sed in-place
sed_inplace() {
    if [[ "$OSTYPE" == "darwin"* ]]; then
        sed -i '' "$@"
    else
        sed -i "$@"
    fi
}

# Helper: Show formatted date header
show_date_header() {
    local date_to_show="$1"
    local date_header
    if [[ "$OSTYPE" == "darwin"* ]]; then
        date_header=$(date -j -f "%Y-%m-%d" "$date_to_show" "+%m%d %a" | tr '[:lower:]' '[:upper:]')
    else
        date_header=$(date -d "$date_to_show" "+%m%d %a" | tr '[:lower:]' '[:upper:]')
    fi
    echo "$date_header"
}

# Helper: Show formatted month header
show_month_header() {
    local month_to_show="$1"
    local month_header
    if [[ "$OSTYPE" == "darwin"* ]]; then
        month_header=$(date -j -f "%Y-%m" "$month_to_show" "+%Y %b" | tr '[:lower:]' '[:upper:]')
    else
        month_header=$(date -d "$month_to_show-01" "+%Y %b" | tr '[:lower:]' '[:upper:]')
    fi
    echo "$month_header"
}

# Helper: Get task line number in file
get_task_line() {
    local num="$1"
    local file="${2:-$FILE}"

    local lines
    lines=$(grep -v "^#" "$file" | grep -v "^$" || true)

    local total
    total=$(echo "$lines" | wc -l | tr -d ' ')

    if [[ $num -lt 1 ]] || [[ $num -gt $total ]]; then
        echo "Error: Task $num not found (1-$total)" >&2
        return 1
    fi

    local line_nums
    line_nums=$(grep -n -v "^#" "$file" | grep -v ":$" | cut -d: -f1)
    echo "$line_nums" | sed -n "${num}p"
}

# Helper: Parse date argument to YYYY-MM-DD format
parse_date() {
    local date_arg="$1"

    if [[ "$date_arg" == "today" ]]; then
        date +%Y-%m-%d
    elif [[ "$date_arg" =~ ^[0-9]{8}$ ]]; then
        # YYYYMMDD
        echo "${date_arg:0:4}-${date_arg:4:2}-${date_arg:6:2}"
    elif [[ "$date_arg" =~ ^[0-9]{4}$ ]]; then
        # MMDD
        echo "$(date +%Y)-${date_arg:0:2}-${date_arg:2:2}"
    else
        echo "Error: Invalid date format" >&2
        echo "Date must be in format MMDD or YYYYMMDD" >&2
        echo "Example: 1225 (Dec 25) or 20251225 (Dec 25, 2025)" >&2
        return 1
    fi
}

# Helper: Validate date format
validate_date() {
    local date_str="$1"
    if ! date -j -f "%Y-%m-%d" "$date_str" &>/dev/null && ! date -d "$date_str" &>/dev/null; then
        echo "Error: Invalid date '$date_str'" >&2
        return 1
    fi
    return 0
}

# Helper: Parse month argument to YYYY-MM format
parse_month() {
    local month_arg="$1"

    if [[ "$month_arg" =~ ^[0-9]{6}$ ]]; then
        # YYYYMM
        echo "${month_arg:0:4}-${month_arg:4:2}"
    elif [[ "$month_arg" =~ ^[0-9]{2}$ ]]; then
        # MM (current year)
        echo "$(date +%Y)-${month_arg}"
    else
        echo "Error: Invalid month format" >&2
        echo "Month must be in format MM or YYYYMM" >&2
        echo "Example: 12 (Dec this year) or 202601 (Jan 2026)" >&2
        return 1
    fi
}

# Helper: Validate month format
validate_month() {
    local month_str="$1"
    # Check format YYYY-MM and valid month (01-12)
    if ! [[ "$month_str" =~ ^[0-9]{4}-[0-9]{2}$ ]]; then
        echo "Error: Invalid month format '$month_str'" >&2
        return 1
    fi
    local month="${month_str:5:2}"
    if [[ $month -lt 1 ]] || [[ $month -gt 12 ]]; then
        echo "Error: Invalid month '$month' (must be 01-12)" >&2
        return 1
    fi
    return 0
}

# Helper: Create or ensure file exists
ensure_file() {
    local file_path="$1"
    local file_date="$2"

    if [[ ! -f "$file_path" ]]; then
        echo "# $file_date" > "$file_path"
        echo "" >> "$file_path"
    fi
}

# Helper: Get month name from number (01-12)
get_month_name() {
    local month_num="$1"
    case "$month_num" in
        01) echo "JANUARY" ;;
        02) echo "FEBRUARY" ;;
        03) echo "MARCH" ;;
        04) echo "APRIL" ;;
        05) echo "MAY" ;;
        06) echo "JUNE" ;;
        07) echo "JULY" ;;
        08) echo "AUGUST" ;;
        09) echo "SEPTEMBER" ;;
        10) echo "OCTOBER" ;;
        11) echo "NOVEMBER" ;;
        12) echo "DECEMBER" ;;
        *) echo "UNKNOWN" ;;
    esac
}

# Helper: Ensure month section exists in future log
ensure_month_section() {
    local file_path="$1"
    local month_name="$2"

    # Check if month header exists
    if ! grep -q "^\[${month_name}\]$" "$file_path" 2>/dev/null; then
        # Add month header at the end
        echo "" >> "$file_path"
        echo "[${month_name}]" >> "$file_path"
    fi
}

# Helper: Add task to month section in future log
add_to_month_section() {
    local file_path="$1"
    local month_name="$2"
    local task_text="$3"

    # Ensure month section exists
    ensure_month_section "$file_path" "$month_name"

    # Read the entire file into an array
    local lines=()
    local in_target_section=false
    local inserted=false

    while IFS= read -r line || [[ -n "$line" ]]; do
        # Check if we're at the target month header
        if [[ "$line" == "[${month_name}]" ]]; then
            lines+=("$line")
            in_target_section=true
            continue
        fi

        # Check if we hit another month header while in target section
        if [[ "$in_target_section" == "true" ]] && [[ "$line" =~ ^\[.*\]$ ]]; then
            # Insert before this next header
            lines+=("$task_text")
            lines+=("$line")
            inserted=true
            in_target_section=false
            continue
        fi

        lines+=("$line")
    done < "$file_path"

    # If we didn't insert yet (no next header found), add at end
    if [[ "$inserted" == "false" ]] && [[ "$in_target_section" == "true" ]]; then
        lines+=("$task_text")
    fi

    # Write back to file
    printf "%s\n" "${lines[@]}" > "$file_path"
}

# List tasks (without line numbers)
list() {
    # Show header based on mode
    if [[ "$CURRENT_MODE" == "monthly" ]]; then
        echo "[Monthly] $(show_month_header "$CURRENT_MONTH")"
    elif [[ "$CURRENT_MODE" == "future" ]]; then
        echo "[Future Log] $CURRENT_YEAR"
    else
        echo "[Daily] $(show_date_header "$CURRENT_DATE")"
    fi

    local entries
    entries=$(grep -v "^#" "$FILE" | grep -v "^$" || true)

    if [[ -z "$entries" ]]; then
        if [[ "$CURRENT_MODE" == "monthly" ]]; then
            echo "No monthly logs."
        elif [[ "$CURRENT_MODE" == "future" ]]; then
            echo "No future log entries."
        else
            echo "No tasks."
        fi
    else
        # Strip leading spaces for consistent alignment
        echo "$entries" | sed 's/^[[:space:]]*//'
    fi
}

# Add task
add() {
    local bullet="$1"
    shift
    local text="$*"

    # Validate bullet type for adding
    if [[ ! "$bullet" =~ ^${ADD_BULLET_PATTERN}$ ]]; then
        echo "Error: Invalid bullet '$bullet' for adding tasks" >&2
        echo "Valid bullets for adding: . (task), ! (priority), o (event), - (note)" >&2
        exit 1
    fi

    # Validate task text is not empty
    if [[ -z "$text" ]]; then
        echo "Error: Task text cannot be empty" >&2
        exit 1
    fi

    echo "$bullet  $text" >> "$FILE"
    echo "$bullet  $text"
}

# Change bullet
change() {
    local new_bullet="$1"
    local num="$2"

    # Validate bullet type for changing
    if [[ ! "$new_bullet" =~ ^${CHANGE_BULLET_PATTERN}$ ]]; then
        echo "Error: Invalid bullet '$new_bullet' for changing task status" >&2
        echo "Valid bullets for changing: ! (priority), x (done), o (event), a (abandoned), w (waiting), - (note)" >&2
        exit 1
    fi

    local actual_line
    actual_line=$(get_task_line "$num") || exit 1

    # Get current task and show what will change
    local old_line
    old_line=$(sed -n "${actual_line}p" "$FILE")

    # Preview the change
    local task_text
    task_text=$(echo "$old_line" | sed -E "s/^[[:space:]]*${BULLET_PATTERN}[[:space:]]*//" )
    local new_preview="$new_bullet  $task_text"

    echo "Change: $old_line"
    echo "To:     $new_preview"
    read -p "Are you sure? (y/N): " -n 1 -r
    echo

    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "Cancelled."
        exit 0
    fi

    # Change the bullet - strip leading spaces and ensure consistent format
    sed_inplace "${actual_line}s/^[[:space:]]*${BULLET_PATTERN}/$new_bullet/" "$FILE"

    local new_line
    new_line=$(sed -n "${actual_line}p" "$FILE")
    echo "Changed: $new_line"
}

# Delete task
delete() {
    local num="$1"

    local actual_line
    actual_line=$(get_task_line "$num") || exit 1

    local to_delete
    to_delete=$(sed -n "${actual_line}p" "$FILE")

    # Show task and ask for confirmation
    echo "Delete: $to_delete"
    read -p "Are you sure? (y/N): " -n 1 -r
    echo

    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "Cancelled."
        exit 0
    fi

    sed_inplace "${actual_line}d" "$FILE"
    echo "Deleted."
}

# Navigate to date
navigate() {
    local date_arg="$1"

    local target_date
    target_date=$(parse_date "$date_arg") || exit 1

    validate_date "$target_date" || exit 1

    set_current_date "$target_date"
    set_current_mode "daily"

    local target_file="$BJ_DIR/$target_date.md"
    ensure_file "$target_file" "$target_date"

    # Update FILE variable for list function
    FILE="$target_file"
    CURRENT_DATE="$target_date"
    CURRENT_MODE="daily"

    # Show date header and tasks
    show_date_header "$target_date"

    local entries
    entries=$(grep -v "^#" "$target_file" | grep -v "^$" || true)

    if [[ -z "$entries" ]]; then
        echo "No tasks."
    else
        # Strip leading spaces for consistent alignment
        echo "$entries" | sed 's/^[[:space:]]*//'
    fi
}

# Migrate tasks
migrate() {
    # Get current month (YYYY-MM)
    local current_month="${CURRENT_DATE:0:7}"

    # Calculate next month
    local next_month
    if [[ "$OSTYPE" == "darwin"* ]]; then
        next_month=$(date -v+1m -j -f "%Y-%m" "$current_month" +%Y-%m)
    else
        next_month=$(date -d "$current_month-01 + 1 month" +%Y-%m)
    fi

    # Create target monthly log file
    local target_file="$BJ_DIR/$next_month.md"
    ensure_file "$target_file" "$next_month"

    # Find all daily log files for current month
    local month_files
    month_files=$(ls "$BJ_DIR/$current_month"-*.md 2>/dev/null || true)

    if [[ -z "$month_files" ]]; then
        echo "No daily log files found for $current_month."
        exit 0
    fi

    # Collect all incomplete tasks from all days in current month
    local all_incomplete=""
    local files_with_tasks=()

    while IFS= read -r file; do
        if [[ -z "$file" ]]; then
            continue
        fi

        # Find incomplete tasks (., !, w) - exclude scheduled (<) and already migrated (>)
        local incomplete
        incomplete=$(grep -E "^[[:space:]]*${INCOMPLETE_PATTERN}[[:space:]]" "$file" || true)

        if [[ -n "$incomplete" ]]; then
            all_incomplete="${all_incomplete}${incomplete}"$'\n'
            files_with_tasks+=("$file")
        fi
    done <<< "$month_files"

    # Remove trailing newline
    all_incomplete=$(echo "$all_incomplete" | sed '/^$/d')

    if [[ -z "$all_incomplete" ]]; then
        echo "No incomplete tasks to migrate from $current_month."
        exit 0
    fi

    echo "Migrating incomplete tasks from $current_month to $next_month monthly log:"
    echo "$all_incomplete"
    echo ""

    # Keep original bullets and append to target file (preserve ., !, w)
    echo "$all_incomplete" >> "$target_file"

    # Update each source file - change incomplete to migrated
    for file in "${files_with_tasks[@]}"; do
        local incomplete
        incomplete=$(grep -E "^[[:space:]]*${INCOMPLETE_PATTERN}[[:space:]]" "$file" || true)

        while IFS= read -r line; do
            if [[ -n "$line" ]]; then
                local escaped_line
                escaped_line=$(printf '%s\n' "$line" | sed 's/[]\/$*.^[]/\\&/g')
                # Strip leading spaces and replace bullet with >
                local text_part
                text_part=$(echo "$line" | sed -E "s/^[[:space:]]*${INCOMPLETE_PATTERN}[[:space:]]*//")
                sed_inplace "s/^${escaped_line}$/${BULLET_MIGRATED}  ${text_part}/" "$file"
            fi
        done <<< "$incomplete"
    done

    echo "Migrated to $next_month monthly log!"
}

# Schedule task to specific date
schedule() {
    local num="$1"
    local date_arg="$2"

    # Parse date argument to get year and month
    local target_year
    local target_month

    if [[ "$date_arg" =~ ^[0-9]{6}$ ]]; then
        # YYYYMM format
        target_year="${date_arg:0:4}"
        target_month="${date_arg:4:2}"
    elif [[ "$date_arg" =~ ^[0-9]{2}$ ]]; then
        # MM format - use current year
        target_year="$(date +%Y)"
        target_month="$date_arg"
    else
        echo "Error: Invalid date format" >&2
        echo "Use MM (e.g., 12) or YYYYMM (e.g., 202601)" >&2
        exit 1
    fi

    # Validate month
    if [[ $target_month -lt 1 ]] || [[ $target_month -gt 12 ]]; then
        echo "Error: Invalid month '$target_month' (must be 01-12)" >&2
        exit 1
    fi

    # Get the task line
    local actual_line
    actual_line=$(get_task_line "$num") || exit 1

    # Get the task line with bullet
    local task_line
    task_line=$(sed -n "${actual_line}p" "$FILE")

    # Extract bullet type
    local bullet_type
    bullet_type=$(echo "$task_line" | sed -E "s/^[[:space:]]*([.!xoaw><-])[[:space:]].*/\1/")

    # Extract task text
    local task_text
    task_text=$(echo "$task_line" | sed -E "s/^[[:space:]]*${BULLET_PATTERN}[[:space:]]*//")

    # Check if task already scheduled
    if [[ "$task_text" =~ ^[0-9]{4}-[0-9]{2}:[[:space:]] ]]; then
        echo "Task already scheduled: ${BULLET_SCHEDULED}  $task_text"
        exit 0
    fi

    # Create future log file if needed
    local target_file="$BJ_DIR/${target_year}.md"
    ensure_file "$target_file" "$target_year"

    # Get month name
    local month_name
    month_name=$(get_month_name "$target_month")

    # Add task to month section with original bullet type
    add_to_month_section "$target_file" "$month_name" "${bullet_type}  ${task_text}"

    # Format target date as YYYY-MM
    local target_date="${target_year}-${target_month}"

    # Change bullet to < and add timestamp in current file
    sed_inplace "${actual_line}s/^[[:space:]]*[.!xoaw><-][[:space:]]*/${BULLET_SCHEDULED}  ${target_date}: /" "$FILE"

    echo "Scheduled to $month_name $target_year: ${BULLET_SCHEDULED}  ${target_date}: ${task_text}"
}

# Switch write mode
write_mode() {
    local mode="$1"

    if [[ "$mode" != "daily" ]] && [[ "$mode" != "monthly" ]] && [[ "$mode" != "future" ]]; then
        echo "Error: Invalid mode '$mode'" >&2
        echo "Valid modes: daily, monthly, future" >&2
        exit 1
    fi

    set_current_mode "$mode"

    if [[ "$mode" == "monthly" ]]; then
        echo "Switched to monthly log mode"
        # Initialize current month if not set
        CURRENT_MONTH=$(get_current_month)
        FILE="$BJ_DIR/$CURRENT_MONTH.md"
        ensure_file "$FILE" "$CURRENT_MONTH"
        CURRENT_MODE="monthly"
    elif [[ "$mode" == "future" ]]; then
        echo "Switched to future log mode"
        # Initialize current year if not set
        CURRENT_YEAR=$(get_current_year)
        FILE="$BJ_DIR/$CURRENT_YEAR.md"
        ensure_file "$FILE" "$CURRENT_YEAR"
        CURRENT_MODE="future"
    else
        echo "Switched to daily log mode"
        # Re-initialize to current date
        CURRENT_DATE=$(get_current_date)
        FILE="$BJ_DIR/$CURRENT_DATE.md"
        ensure_file "$FILE" "$CURRENT_DATE"
        CURRENT_MODE="daily"
    fi

    # Show current context
    list
}

# Navigate to month
navigate_month() {
    local month_arg="$1"

    local target_month
    target_month=$(parse_month "$month_arg") || exit 1

    validate_month "$target_month" || exit 1

    set_current_month "$target_month"
    set_current_mode "monthly"

    local target_file="$BJ_DIR/$target_month.md"
    ensure_file "$target_file" "$target_month"

    # Update global variables
    FILE="$target_file"
    CURRENT_MONTH="$target_month"
    CURRENT_MODE="monthly"

    # Show month header and logs
    echo "[Monthly] $(show_month_header "$target_month")"

    local entries
    entries=$(grep -v "^#" "$target_file" | grep -v "^$" || true)

    if [[ -z "$entries" ]]; then
        echo "No monthly logs."
    else
        echo "$entries" | sed 's/^[[:space:]]*//'
    fi
}

# Show help
help() {
    cat <<'EOF'
bj - Minimal Bullet Journal

USAGE:
  bj                  List tasks (daily/monthly/future based on mode)
  bj [text]           Add task (default: .)
  bj [bullet] [text]  Add task with bullet
  bj [bullet] [n]     Change task n to bullet
  bj del [n]          Delete task n
  bj date today       Go to today
  bj date [date]      Go to specific date
  bj migrate          Migrate incomplete tasks from current month to next month
  bj schedule [n] [MM|YYYYMM]  Schedule task n to future log month
  bj write daily      Switch to daily log mode
  bj write monthly    Switch to monthly log mode
  bj write future     Switch to future log mode
  bj month [month]    Navigate to specific month (auto-switches to monthly mode)

BULLETS:
  .  task     x  done      a  abandoned
  !  priority o  event     -  note
  w  waiting  >  migrated  <  scheduled

EXAMPLES:
  bj                  # List tasks in current mode
  bj Buy milk         # Add task ". Buy milk"
  bj o Meeting at 3pm # Add event
  bj x 1              # Mark task 1 as done
  bj del 3            # Delete task 3
  bj date 1225        # Go to Dec 25
  bj migrate          # Migrate all incomplete tasks to next month
  bj schedule 2 12    # Schedule task 2 to December (future log)
  bj schedule 3 202601 # Schedule task 3 to January 2026 (future log)
  bj write monthly    # Switch to monthly logs
  bj write future     # Switch to future log
  bj month 12         # Navigate to December
  bj month 202601     # Navigate to January 2026
  bj write daily      # Switch back to daily logs
EOF
}

# Main
if [[ $# -eq 0 ]]; then
    list
    exit 0
fi

case "$1" in
    -h|--help|help)
        help
        exit 0
        ;;
    -v|--version|version)
        echo "bj version $VERSION"
        exit 0
        ;;
    del)
        if [[ $# -ne 2 ]]; then
            echo "Usage: bj del [n]"
            exit 1
        fi
        delete "$2"
        exit 0
        ;;
    date)
        if [[ $# -ne 2 ]]; then
            echo "Usage: bj date today | bj date MMDD | bj date YYYYMMDD"
            exit 1
        fi
        navigate "$2"
        exit 0
        ;;
    migrate)
        if [[ $# -ne 1 ]]; then
            echo "Usage: bj migrate"
            exit 1
        fi
        migrate
        exit 0
        ;;
    schedule)
        if [[ $# -ne 3 ]]; then
            echo "Usage: bj schedule [n] [MMDD | YYYYMMDD]"
            exit 1
        fi
        schedule "$2" "$3"
        exit 0
        ;;
    write)
        if [[ $# -ne 2 ]]; then
            echo "Usage: bj write daily | bj write monthly"
            exit 1
        fi
        write_mode "$2"
        exit 0
        ;;
    month)
        if [[ $# -ne 2 ]]; then
            echo "Usage: bj month MM | bj month YYYYMM"
            exit 1
        fi
        navigate_month "$2"
        exit 0
        ;;
    .)
        # bj . some task
        add . "${@:2}"
        exit 0
        ;;
    "!"|o|-)
        # Could be: bj ! 1 (change) or bj ! some text (add)
        if [[ $# -eq 2 ]] && [[ "$2" =~ ^[0-9]+$ ]]; then
            change "$1" "$2"
        else
            add "$1" "${@:2}"
        fi
        exit 0
        ;;
    x|a|w)
        # Only for changing status: bj x 1
        if [[ $# -ne 2 ]]; then
            echo "Usage: bj $1 [n]" >&2
            exit 1
        fi
        if [[ ! "$2" =~ ^[0-9]+$ ]]; then
            echo "Error: Bullet '$1' can only be used for changing task status, not adding tasks" >&2
            echo "Usage: bj $1 [task_number]" >&2
            exit 1
        fi
        change "$1" "$2"
        exit 0
        ;;
    *)
        # Check if first argument looks like an invalid bullet attempt
        if [[ ${#1} -eq 1 ]] && [[ ! "$1" =~ ^${ADD_BULLET_PATTERN}$ ]]; then
            echo "Error: Invalid bullet '$1' for adding tasks" >&2
            echo "Valid bullets for adding: . (task), ! (priority), o (event), - (note)" >&2
            exit 1
        fi
        # bj some text - add as task
        add . "$@"
        exit 0
        ;;
esac
