#!/bin/bash
#
# bj - Minimal Bullet Journal
# Version: 1.0.0

set -euo pipefail

# Constants
readonly VERSION="1.0.0"
readonly BJ_DIR="${BJ_HOME:-$HOME/bj}"
readonly CACHE_FILE="$BJ_DIR/.current_date"

# Bullet type constants
readonly BULLET_TASK="."
readonly BULLET_PRIORITY="!"
readonly BULLET_DONE="x"
readonly BULLET_EVENT="o"
readonly BULLET_ABANDONED="a"
readonly BULLET_WAITING="w"
readonly BULLET_MIGRATED=">"
readonly BULLET_SCHEDULED="<"
readonly BULLET_NOTE="-"

# Regex patterns
readonly BULLET_PATTERN='[.!xoaw><-]'
readonly INCOMPLETE_PATTERN='[.!w]'
readonly ADD_BULLET_PATTERN='[.!o-]'
readonly CHANGE_BULLET_PATTERN='[!xoaw-]'

mkdir -p "$BJ_DIR"

# Get current working date
get_current_date() {
    if [[ -f "$CACHE_FILE" ]]; then
        cat "$CACHE_FILE"
    else
        date +%Y-%m-%d
    fi
}

# Set current working date
set_current_date() {
    echo "$1" > "$CACHE_FILE"
}

CURRENT_DATE=$(get_current_date)
FILE="$BJ_DIR/$CURRENT_DATE.md"

# Create file if needed
if [[ ! -f "$FILE" ]]; then
    echo "# $CURRENT_DATE" > "$FILE"
    echo "" >> "$FILE"
fi

# Portable sed in-place
sed_inplace() {
    if [[ "$OSTYPE" == "darwin"* ]]; then
        sed -i '' "$@"
    else
        sed -i "$@"
    fi
}

# Helper: Show formatted date header
show_date_header() {
    local date_to_show="$1"
    local date_header
    if [[ "$OSTYPE" == "darwin"* ]]; then
        date_header=$(date -j -f "%Y-%m-%d" "$date_to_show" "+%m%d %a" | tr '[:lower:]' '[:upper:]')
    else
        date_header=$(date -d "$date_to_show" "+%m%d %a" | tr '[:lower:]' '[:upper:]')
    fi
    echo "$date_header"
}

# Helper: Get task line number in file
get_task_line() {
    local num="$1"
    local file="${2:-$FILE}"

    local lines
    lines=$(grep -v "^#" "$file" | grep -v "^$" || true)

    local total
    total=$(echo "$lines" | wc -l | tr -d ' ')

    if [[ $num -lt 1 ]] || [[ $num -gt $total ]]; then
        echo "Error: Task $num not found (1-$total)" >&2
        return 1
    fi

    local line_nums
    line_nums=$(grep -n -v "^#" "$file" | grep -v ":$" | cut -d: -f1)
    echo "$line_nums" | sed -n "${num}p"
}

# Helper: Parse date argument to YYYY-MM-DD format
parse_date() {
    local date_arg="$1"

    if [[ "$date_arg" == "today" ]]; then
        date +%Y-%m-%d
    elif [[ "$date_arg" =~ ^[0-9]{8}$ ]]; then
        # YYYYMMDD
        echo "${date_arg:0:4}-${date_arg:4:2}-${date_arg:6:2}"
    elif [[ "$date_arg" =~ ^[0-9]{4}$ ]]; then
        # MMDD
        echo "$(date +%Y)-${date_arg:0:2}-${date_arg:2:2}"
    else
        echo "Error: Invalid date format" >&2
        echo "Date must be in format MMDD or YYYYMMDD" >&2
        echo "Example: 1225 (Dec 25) or 20251225 (Dec 25, 2025)" >&2
        return 1
    fi
}

# Helper: Validate date format
validate_date() {
    local date_str="$1"
    if ! date -j -f "%Y-%m-%d" "$date_str" &>/dev/null && ! date -d "$date_str" &>/dev/null; then
        echo "Error: Invalid date '$date_str'" >&2
        return 1
    fi
    return 0
}

# Helper: Create or ensure file exists
ensure_file() {
    local file_path="$1"
    local file_date="$2"

    if [[ ! -f "$file_path" ]]; then
        echo "# $file_date" > "$file_path"
        echo "" >> "$file_path"
    fi
}

# List tasks (without line numbers)
list() {
    show_date_header "$CURRENT_DATE"

    local entries
    entries=$(grep -v "^#" "$FILE" | grep -v "^$" || true)

    if [[ -z "$entries" ]]; then
        echo "No tasks."
    else
        # Strip leading spaces for consistent alignment
        echo "$entries" | sed 's/^[[:space:]]*//'
    fi
}

# Add task
add() {
    local bullet="$1"
    shift
    local text="$*"

    # Validate bullet type for adding
    if [[ ! "$bullet" =~ ^${ADD_BULLET_PATTERN}$ ]]; then
        echo "Error: Invalid bullet '$bullet' for adding tasks" >&2
        echo "Valid bullets for adding: . (task), ! (priority), o (event), - (note)" >&2
        exit 1
    fi

    # Validate task text is not empty
    if [[ -z "$text" ]]; then
        echo "Error: Task text cannot be empty" >&2
        exit 1
    fi

    echo "$bullet  $text" >> "$FILE"
    echo "$bullet  $text"
}

# Change bullet
change() {
    local new_bullet="$1"
    local num="$2"

    # Validate bullet type for changing
    if [[ ! "$new_bullet" =~ ^${CHANGE_BULLET_PATTERN}$ ]]; then
        echo "Error: Invalid bullet '$new_bullet' for changing task status" >&2
        echo "Valid bullets for changing: ! (priority), x (done), o (event), a (abandoned), w (waiting), - (note)" >&2
        exit 1
    fi

    local actual_line
    actual_line=$(get_task_line "$num") || exit 1

    # Get current task and show what will change
    local old_line
    old_line=$(sed -n "${actual_line}p" "$FILE")

    # Preview the change
    local task_text
    task_text=$(echo "$old_line" | sed -E "s/^[[:space:]]*${BULLET_PATTERN}[[:space:]]*//" )
    local new_preview="$new_bullet  $task_text"

    echo "Change: $old_line"
    echo "To:     $new_preview"
    read -p "Are you sure? (y/N): " -n 1 -r
    echo

    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "Cancelled."
        exit 0
    fi

    # Change the bullet - strip leading spaces and ensure consistent format
    sed_inplace "${actual_line}s/^[[:space:]]*${BULLET_PATTERN}/$new_bullet/" "$FILE"

    local new_line
    new_line=$(sed -n "${actual_line}p" "$FILE")
    echo "Changed: $new_line"
}

# Delete task
delete() {
    local num="$1"

    local actual_line
    actual_line=$(get_task_line "$num") || exit 1

    local to_delete
    to_delete=$(sed -n "${actual_line}p" "$FILE")

    # Show task and ask for confirmation
    echo "Delete: $to_delete"
    read -p "Are you sure? (y/N): " -n 1 -r
    echo

    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "Cancelled."
        exit 0
    fi

    sed_inplace "${actual_line}d" "$FILE"
    echo "Deleted."
}

# Navigate to date
navigate() {
    local date_arg="$1"

    local target_date
    target_date=$(parse_date "$date_arg") || exit 1

    validate_date "$target_date" || exit 1

    set_current_date "$target_date"

    local target_file="$BJ_DIR/$target_date.md"
    ensure_file "$target_file" "$target_date"

    # Update FILE variable for list function
    FILE="$target_file"
    CURRENT_DATE="$target_date"

    # Show date header and tasks
    show_date_header "$target_date"

    local entries
    entries=$(grep -v "^#" "$target_file" | grep -v "^$" || true)

    if [[ -z "$entries" ]]; then
        echo "No tasks."
    else
        # Strip leading spaces for consistent alignment
        echo "$entries" | sed 's/^[[:space:]]*//'
    fi
}

# Migrate tasks
migrate() {
    local target_date

    # Get tomorrow's date
    if [[ "$OSTYPE" == "darwin"* ]]; then
        target_date=$(date -v+1d -j -f "%Y-%m-%d" "$CURRENT_DATE" +%Y-%m-%d)
    else
        target_date=$(date -d "$CURRENT_DATE + 1 day" +%Y-%m-%d)
    fi

    # Create target file if needed
    local target_file="$BJ_DIR/$target_date.md"
    ensure_file "$target_file" "$target_date"

    # Find incomplete tasks (., !, w) - exclude scheduled (<) and already migrated (>)
    local incomplete
    incomplete=$(grep -E "^[[:space:]]*${INCOMPLETE_PATTERN}[[:space:]]" "$FILE" || true)

    if [[ -z "$incomplete" ]]; then
        echo "No incomplete tasks to migrate."
        exit 0
    fi

    echo "Migrating incomplete tasks to $target_date:"
    echo "$incomplete"
    echo ""

    # Change bullets to > (migrated) and append to target file
    local migrated
    migrated=$(echo "$incomplete" | sed "s/^[[:space:]]*${INCOMPLETE_PATTERN}/${BULLET_MIGRATED}/")
    echo "$migrated" >> "$target_file"

    # Update current file - change incomplete to migrated
    while IFS= read -r line; do
        if [[ -n "$line" ]]; then
            local escaped_line
            escaped_line=$(printf '%s\n' "$line" | sed 's/[]\/$*.^[]/\\&/g')
            # Strip leading spaces and replace bullet with >
            local text_part
            text_part=$(echo "$line" | sed -E "s/^[[:space:]]*${INCOMPLETE_PATTERN}[[:space:]]*//")
            sed_inplace "s/^${escaped_line}$/${BULLET_MIGRATED}  ${text_part}/" "$FILE"
        fi
    done <<< "$incomplete"

    echo "Migrated to $target_date!"
}

# Schedule task to specific date
schedule() {
    local num="$1"
    local date_arg="$2"

    # Parse and validate date
    local target_date
    target_date=$(parse_date "$date_arg") || exit 1
    validate_date "$target_date" || exit 1

    # Check if target date is in the past
    if [[ "$target_date" < "$CURRENT_DATE" ]]; then
        echo "Error: Cannot schedule to past date ($target_date)" >&2
        exit 1
    fi

    # Get the task line
    local actual_line
    actual_line=$(get_task_line "$num") || exit 1

    # Get the task text
    local task_line
    task_line=$(sed -n "${actual_line}p" "$FILE")
    local task_text
    task_text=$(echo "$task_line" | sed -E "s/^[[:space:]]*${BULLET_PATTERN}[[:space:]]*//")

    # Check if task already has a timestamp (YYYY-MM-DD: format)
    if [[ "$task_text" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}:[[:space:]] ]]; then
        echo "Task already scheduled: ${BULLET_SCHEDULED}  $task_text"
        exit 0
    fi

    # Create target file if needed
    local target_file="$BJ_DIR/$target_date.md"
    ensure_file "$target_file" "$target_date"

    # Add timestamp prefix for current day
    local scheduled_text="$target_date: $task_text"

    # Add as regular task (.) on target date (without timestamp)
    echo "${BULLET_TASK}  $task_text" >> "$target_file"

    # Change bullet to < and add timestamp in current file
    sed_inplace "${actual_line}s/^[[:space:]]*${BULLET_PATTERN}[[:space:]]*/${BULLET_SCHEDULED}  $target_date: /" "$FILE"

    echo "Scheduled to $target_date: ${BULLET_SCHEDULED}  $scheduled_text"
}

# Show help
help() {
    cat <<'EOF'
bj - Minimal Bullet Journal

USAGE:
  bj                  List tasks
  bj [text]           Add task (default: .)
  bj [bullet] [text]  Add task with bullet
  bj [bullet] [n]     Change task n to bullet
  bj del [n]          Delete task n
  bj date today       Go to today
  bj date [date]      Go to specific date
  bj migrate          Migrate tasks to tomorrow
  bj schedule [n] [date]  Schedule task n to date

BULLETS:
  .  task     x  done      a  abandoned
  !  priority o  event     -  note
  w  waiting  >  migrated  <  scheduled

EXAMPLES:
  bj                  # List all tasks
  bj Buy milk         # Add task ". Buy milk"
  bj o Meeting at 3pm # Add event
  bj x 1              # Mark task 1 as done
  bj del 3            # Delete task 3
  bj date 1225        # Go to Dec 25
  bj migrate          # Migrate to tomorrow
  bj schedule 2 1225  # Schedule task 2 to Dec 25
EOF
}

# Main
if [[ $# -eq 0 ]]; then
    list
    exit 0
fi

case "$1" in
    -h|--help|help)
        help
        exit 0
        ;;
    -v|--version|version)
        echo "bj version $VERSION"
        exit 0
        ;;
    del)
        if [[ $# -ne 2 ]]; then
            echo "Usage: bj del [n]"
            exit 1
        fi
        delete "$2"
        exit 0
        ;;
    date)
        if [[ $# -ne 2 ]]; then
            echo "Usage: bj date today | bj date MMDD | bj date YYYYMMDD"
            exit 1
        fi
        navigate "$2"
        exit 0
        ;;
    migrate)
        if [[ $# -ne 1 ]]; then
            echo "Usage: bj migrate"
            exit 1
        fi
        migrate
        exit 0
        ;;
    schedule)
        if [[ $# -ne 3 ]]; then
            echo "Usage: bj schedule [n] [MMDD | YYYYMMDD]"
            exit 1
        fi
        schedule "$2" "$3"
        exit 0
        ;;
    .)
        # bj . some task
        add . "${@:2}"
        exit 0
        ;;
    "!"|o|-)
        # Could be: bj ! 1 (change) or bj ! some text (add)
        if [[ $# -eq 2 ]] && [[ "$2" =~ ^[0-9]+$ ]]; then
            change "$1" "$2"
        else
            add "$1" "${@:2}"
        fi
        exit 0
        ;;
    x|a|w)
        # Only for changing status: bj x 1
        if [[ $# -ne 2 ]]; then
            echo "Usage: bj $1 [n]" >&2
            exit 1
        fi
        if [[ ! "$2" =~ ^[0-9]+$ ]]; then
            echo "Error: Bullet '$1' can only be used for changing task status, not adding tasks" >&2
            echo "Usage: bj $1 [task_number]" >&2
            exit 1
        fi
        change "$1" "$2"
        exit 0
        ;;
    *)
        # Check if first argument looks like an invalid bullet attempt
        if [[ ${#1} -eq 1 ]] && [[ ! "$1" =~ ^${ADD_BULLET_PATTERN}$ ]]; then
            echo "Error: Invalid bullet '$1' for adding tasks" >&2
            echo "Valid bullets for adding: . (task), ! (priority), o (event), - (note)" >&2
            exit 1
        fi
        # bj some text - add as task
        add . "$@"
        exit 0
        ;;
esac
